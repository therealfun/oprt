#!/bin/bash

. ${BASH_SOURCE%/*}/oprt_lib

main() {
	(( $# == 0 ))            \
		|| (( $# == 2 )) \
		|| lib_fatal_errorf '%s' "two arguments are required, or none"

	remove_old_source_files "${1:-default}"
	remove_old_packages     "${2:-default}"
}

remove_old_source_files() {
	local _SRC_DIR=$1

	[[ $_SRC_DIR == default ]] && {
		_SRC_DIR=$(. /etc/pkgmk.conf; echo $PKGMK_SOURCE_DIR)
		[[ $_SRC_DIR == "" || $_SRC_DIR == $PWD ]] \
			&& return
	}

	[[ $_SRC_DIR == none ]] \
		&& return

	echo "Remove old sources..."

	declare -A _USED
	local _PORT _INSTALLED
	readarray -t _INSTALLED < <( pkginfo --installed | awk '{print $1}' )

	for _PORT in "${_INSTALLED[@]}"; do
		local _SRC _SOURCES
		readarray -t _SOURCES < <( get_remote_sources "$_PORT" )

		for _SRC in "${_SOURCES[@]}"; do
			_USED["$_SRC"]=1
		done
	done

	remove_unused_old_files_from_dir "$_SRC_DIR" 30
}

get_remote_sources() {
	local _PORT=$1

	lib_set_PORT_DIR_and_COLLECTIONS "$_PORT"

	. "$_PORT_DIR/Pkgfile"

	local _SRC
	local _REMOTE_FILE="^(http|https|ftp|file)://.*/(.+)"
	local _DUMB_FILE="^v?[0-9]"
	for _SRC in "${source[@]}"; do
		[[ $_SRC =~ $_REMOTE_FILE ]] || continue

		local _FILE=${BASH_REMATCH[2]}
		                               printf '%s\n'        "$_FILE"
		[[ $_FILE =~ $_DUMB_FILE ]] && printf '%s\n' "$_PORT-$_FILE"
	done
}

remove_unused_old_files_from_dir() {
	local _DIR=$1
	local _DAYS=$2

	local _FILE
	for _FILE in $_DIR/*; do
		[[ -f $_FILE ]] \
			|| continue

		[[ ${_USED["${_FILE##*/}"]+defined} ]] \
			&& continue

		is_newer_than_n_days "$_FILE" $_DAYS \
			|| ( set -x; lib_run_cmd rm -- "$_FILE" )
	done
}

remove_old_packages() {
	local _PKG_DIR=$1

	[[ $_PKG_DIR == default ]] && {
		_PKG_DIR=$(. /etc/pkgmk.conf; echo $PKGMK_PACKAGE_DIR)
		[[ $_PKG_DIR == "" ]] && _PKG_DIR=/usr/ports
	}

	[[ $_PKG_DIR == none ]] \
		&& return

	echo "Remove old packages..."

	# Find recursively, to work with default settings too.
	#  - find prints "pkg_filename mtime pkg_dir"
	#  - sed rewrite to "port_name version mtime pkg_dir"
	#  - first sort drops duplicates sorted by name and version
	#  - second sort order by name and mtime
	#  - awk shows "path/name#version.pkg.tar.*" for 
	#      older than 3 versions and older than 30 days
	#  - xargs formats "rm" shell commands
	#  - sh executes those commands

	find "$_PKG_DIR" -name '*#*.pkg.tar.*' -printf '%T@ %h %f\n' \
		| sed   --expression='s/#/ /'                        \
			--expression='s/.pkg.tar.*//'                \
		| sort --key=3,4 --unique                            \
		| sort --key=3,3 --key=1,1r                          \
		| awk                                                \
			--assign=MAX_N=3                             \
			--assign=MAX_DAYS=30                         \
			'
			BEGIN     { now=systime()    }
			(NF == 2) { installed[$1]=$2 }
			(NF == 4) {
			  if (port[$3] >= MAX_N || (port[$3] == 0 && !installed[$3])) {
			    n=MAX_DAYS
			    if (port[$3] == 0)
			      n=n*4
			    if (now > $1 && (now - $1)/(60*60*24) > n)
			      print $2 "/" $3 "#" $4 ".pkg.tar.* "
			  } else {
			    port[$3]++
			  }
			}
			' <(pkginfo --installed) /dev/stdin           \
		| xargs --no-run-if-empty --max-args=1 echo rm        \
		| sh -x -
}

is_newer_than_an_year() {
	is_newer_than_n_days "$1" 365
}

is_newer_than_n_days() {
	local _FILE=$1
	local _DAYS=$2

	local _NOW="$(date +%s)"
	local _LIMIT=$(( $_NOW - $_DAYS * 24 * 60 * 60 ))

	# Using change time (%Z) instead of modification time (%Y)
	# because wget creates files with the original modification time

	local _TIME="$(stat --format='%Z' "$_FILE")"

	(( $_TIME > $_LIMIT ))
}

main "$@"
